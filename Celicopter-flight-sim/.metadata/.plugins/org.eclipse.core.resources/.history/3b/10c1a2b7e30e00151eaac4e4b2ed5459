import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import javax.swing.JFrame;

public class Test extends Canvas{
	/**
	 * 
	 */
	public Rectangle virtualBounds;

	public static void main(String []args){
		Test t=new Test();
		JFrame f=new JFrame();

		/*
		//Gets information related to the display screen. This only works for single-monitor devices
		Toolkit tk = Toolkit.getDefaultToolkit();  

		//Gets the width of the screen and stores it in variable xSize
	    int xSize = ((int) tk.getScreenSize().getWidth()); 

	    //Gets the height of the screen and stores it in variable ySize
	    int ySize = ((int) tk.getScreenSize().getHeight());  

	    //Sets the screen to it's maximum allowable size (maximizes screen)
	    f.setSize(xSize,ySize);
		 */
		
		f.setSize((int)t.virtualBounds.getWidth(),(int)t.virtualBounds.getWidth());
		f.add(t);
		f.setVisible(true);
		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				System.exit(0);
			}//closes window listener that closes the program when we exit out of the window
		}//closes patch
		);
	}

	public Test() {
		super();
		/**This code works for devices with multiple screens*/
		//Defines a variable to hold the maximum bounds of the screen we will find shortly
		virtualBounds = new Rectangle();
		//Gets an object that encapsulates all periphery devices attached to this computer (screens, printers, etc.)
		GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
		//Unpacks this object and gets a list of all peripheries 
		GraphicsDevice[] gs = ge.getScreenDevices();
		//Iterates through this list, going to each device, getting the list of settings with each device, and parsing the maximum window size from these settings  
		for (int j = 0; j < gs.length; j++) {
			//Gets the list of settings associated with the device the for loop is currently on
			GraphicsConfiguration[] gc =gs[j].getConfigurations();
			//Iterates through the settings to get the bounds
			for (int i=0; i < gc.length; i++) {
				virtualBounds =virtualBounds.union(gc[i].getBounds());
			}
		}
	}
	
	public void paint(Graphics g){
//		for(int i=3;i<=20;i++){
//			g.setColor(new Color(12*i,12*i,12*i));
//			g.fillPolygon(createPoly(i,182));
//		}
		//g.fillPolygon(createPoly(5,182));
		g.setColor(Color.GREEN);
		g.fillPolygon(createPoly(3,182));
		//g.setColor(Color.BLUE);
		//g.fillPolygon(createPoly(7,182));
	}
	
	private Polygon createPoly(int numberOfSides,double SF){
		int[] xPts=new int[numberOfSides];
		int[] yPts=new int[numberOfSides];
		double intAngle=2*Math.PI/numberOfSides;
		double r;
		if(numberOfSides%2==0)
			r=SF/(2*Math.cos(intAngle/2));
		else
			r=SF/(1+Math.cos(intAngle/2));
		//double r=sideLength/(2*Math.sin(intAngle/2));
		double theta=(3*Math.PI/2)-intAngle/2;
		for(int i=0;i<numberOfSides;i++){
			xPts[i]=(int) Math.round((r*Math.cos(theta+i*intAngle)));
			yPts[i]=(int) Math.round((r*Math.sin(theta+i*intAngle)));
		}
		Polygon p= new Polygon(xPts,yPts,numberOfSides);
		p.translate(-1*min(xPts), -1*min(yPts));
		for(int i=0;i<numberOfSides;i++){
			xPts[i]+=-1*min(xPts);
			yPts[i]+=-1*min(yPts);
			System.out.println("Corrdiantes are:("+xPts[i]+","+yPts[i]+")");
		}
		//Error from the top by polygon # of sides:
		//#3->30px #4->0px #5->9
		System.out.println("Width is: "+p.getBounds2D().getWidth()+". Height is: "+p.getBounds2D().getHeight());
		return p;
	}
	
	private int min(int[] ford){
		int max=ford[0];
		for(int i=1;i<ford.length;i++)
			if(ford[i]<=max)
				max=ford[i];
		return max;
	}
	
}