import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;

import javax.swing.JFrame;
import javax.swing.JPanel;

import joystick.JInputJoystick;
import net.java.games.input.Controller;

public class MainExperimentGroupLine extends JPanel implements Runnable{

	/**
	 * 
	 */
	private static final long serialVersionUID = -8042350635458523909L;
	/**Represents the total bounds of the window in which our experiment happens. 
	 * Expands to occupy two monitors
	 * This variable is dynamic and changes depending on the size of the screen is*/
	protected Dimension screenDimentions;
	/**Holds the graphics object that stuff is drawn on*/
	protected BufferedImage canvas;
	/**Represents the target object to track*/
	protected TargetGroup target;
	/**Holds all the things to be displayed on the screen, including the Target, Curseor, and scenery objects (if there need be screen objects)*/
	protected ArrayList<ScreenObject> allOnScreenObjects=new ArrayList<ScreenObject>();
	/**Represents the on-screen object the user controls. The class name Cursor was already taken so for our class we simply misspelled the word*/
	protected CursorLine warfighter;
	/**Holds the last time the loop was run. Used to calculate the speeds at which everything on-screen moves*/
	protected long lastDrawTime;
	/**True if stick and program are calibrated properly*/
	protected boolean isCalibrated=false;
	/**All the things you would ever want to know about the state of the control stick*/
	protected JInputJoystick stick;
	/**True if the experiment is running, false otherwise*/
	protected boolean isRunning=true;
	/**The time delay, in milliseconds, between frame updates*/
	protected static final int DELAY_TIME=30;
	/**Number of objects on screen that are part of the scenery*/
	protected static final int NUMBER_OF_SCENERY_OBJECTS=4;
	/**Delay between iterations (an iteration is composed of a modulation-spatial frequency combination) in milliseconds*/
	protected static final int ITERATIONS_DELAY=8000;
	/**First thread; handles drawing objects on-screen*/
	protected Thread thread;
	/**Seconds thread; handles moving on-screen objects*/
	protected Thread thread2;
	/**Locking object; used to prevent threads from potentially accessing the same data at the same time*/
	protected Object lock1=new Object();
	/**Graphics object that encapsulate the graphics of the canvas*/
	protected Graphics2D canvasGraphics;
	/**Index of current position in pixelWidths array*/
	protected int pixelWidthIndex=0;
	/**Index of current position in modulations array*/
	protected int modIndex=0;
	/**Target Position Index*/
	protected int targetPositionIndex=0;
	/**Array holding all possible positions of the target. Program iterates over this and draws the target at these x-locations*/
	protected int[] targetPositions;	
	/**Holds the last time an iteration was run*/
	protected long lastIterationTime;
	/**PrinterWriter used to write the results to a CSV file*/
	protected PrintWriter outputFile;
	/**The time according to the internal clock that the program starts at*/
	protected long startTime;
	protected boolean flag;
	protected static int XGain=2;
	
	
	public MainExperimentGroupLine(){
		super();
		
		//Set this to true to enable multi-screening
		boolean IS_MULTI_SCREEN=false;
		if(IS_MULTI_SCREEN)
			XGain=3*XGain;
		
		//Creates the file-writer
		try {
			outputFile = new PrintWriter("Data_Output.csv");
			outputFile.println("Spatial Frequency(Hz),Modulation(0-1),System time(milliseconds),Target Position(pixels),Cursor Position(pixels),Error(pixels),x-axis gain");
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
			System.err.println("Output file could not be created-Fatal error. Program closing...");
			System.exit(0);
		}
		
		startTime=System.currentTimeMillis();
		
		/**This code should work for devices with multiple screens*/
		//Defines a variable to hold the maximum bounds of the screen we will find shortly
		Rectangle virtualBounds = new Rectangle();
		//Gets an object that encapsulates all periphery devices attached to this computer (screens, printers, etc.)
		GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
		//Unpacks this object and gets a list of all peripheries 
		GraphicsDevice[] gs = ge.getScreenDevices();
		//Iterates through this list, going to each device, getting the list of settings with each device, and parsing the maximum window size from these settings  
		for (int j = 0; j < gs.length; j++) {
			//Gets the list of settings associated with the device the for loop is currently on
			GraphicsConfiguration[] gc =gs[j].getConfigurations();
			//Iterates through the settings to get the bounds
			for (int i=0; i < gc.length; i++) {
				virtualBounds =virtualBounds.union(gc[i].getBounds());
			}
		}
		
		double[] amplitudes={1.22,1.116,0.978,0.707,0.457,0.251,0.143,0.091,0.07,0.061};
		double[] freq={0.230,0.460,0.690,1.151,1.764,2.838,4.449,7.056,11.121,17.487};
		double[] ph={0.365,1.990,0.873,-0.306,-1.461,0.131,3.240,0.235,-2.423,-2.249};
		SumOfSines s=new SumOfSines(amplitudes,freq,ph);
		targetPositions=new int[680];
		for(int i=0;i<targetPositions.length;i++)
			targetPositions[i]=s.evaluate(i*DELAY_TIME);
		//Sets the screen dimensions to the size of the window. 
		screenDimentions=new Dimension(virtualBounds.width,virtualBounds.height);
		
		//Creates new frame to hold and display our game object
		JFrame jiff=new JFrame("IMPORTANT RESEARCH PROGRAME");
		if(!IS_MULTI_SCREEN){
			//If the user wants the experiment to take up a single screen, this allows for that
			virtualBounds=new Rectangle(Toolkit.getDefaultToolkit().getScreenSize());
		}
		//Sets the bounds of the experiment display to take up the amount of screens the user wants to take up
		jiff.setBounds(virtualBounds);
		//Adds our canvas to the frame
		jiff.add(this);
		//Makes the program stop when we close the window. This is important for not making the computer excessively slow and preventing memory leaks
		jiff.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		//Allows us to resize the window if need be. Gives our program flexibility
		jiff.setResizable(true);

		/*Used to make the experiment double-buffered (animation looks smoother)
		 * Double-buffering utilizes an offscreen image (that takes up the whole screen)
		 * to draw to first. In actuality when one calls the paint(Graphics g) or repaint() method
		 * on a canvas object in Java, Java will render to the screen, pixel row by pixcel row 
		 * (starting at the top of the screen), the object. If one has lots of objects on the screen,
		 * then this process takes long enough that oen can see the image forming, row by row, 
		 * which looks ugly. By using double-buffering, one draws to an image first, then the image is 
		 * effectively dumped onto the screen in one go, eliminating the lines and making the program run smoother*/
		canvas=new BufferedImage(virtualBounds.width,virtualBounds.height,BufferedImage.TYPE_INT_ARGB);

		//Holds the Graphics object of the image. Commands to draw stuff on the screen (like the Target and Curseor) are sent to this object
		canvasGraphics=(Graphics2D) canvas.getGraphics();

		//Allows the program to get input off the joystick somewhat faster
		requestFocus();

		//Gets the current time off the processor and store it 
		lastDrawTime = System.currentTimeMillis();
		lastIterationTime=lastDrawTime;

		//Ties the joystick to the program so information can be pulled from the joystick
		stick=new JInputJoystick(Controller.Type.STICK);

		//Initializes all on-screen objects
		initObjects();

		//Allows us to see the frame we just made so we can actually see our experiment
		jiff.setVisible(true);

		//Creates the first thread that will handle the displaying of the objects on-screen
		thread=new Thread(this);
		
		//Creates the second thread that will handle moving the objects 
		thread2=new Thread(){
			public void run(){
				//Runs while thread is active and the experiment is running 
				while(Thread.currentThread()==thread2 && isRunning){
					//The syncronized tag prevents the program from both moving and drawing everything on the screen at the same time
					synchronized(lock1){
						if(isCalibrated)
							moveObjects();
					}
					//Pauses for delayTime milliseconds to make things smoother
					try{ Thread.sleep(DELAY_TIME);} catch(InterruptedException e) {e.printStackTrace();}
				}
			}
		};
		//Starts the drawing thread which begins executing what's in the run() method of this program
		thread.start();
		
		//Starts the thread that handles moving all on-screen objects
		thread2.start();
		flag=false;
	}
	
	public void writeErrorToFile(){
		outputFile.println(
				(System.currentTimeMillis()-startTime)+"," + target.xCenterPosition + "," + warfighter.xCenterPosition + ","
				+ warfighter.getError(target) + "," 
				//+ stick.getXAxisValue() +"," 
				);
		if(warfighter.getDynamicMod()!=null)
			outputFile.println(warfighter.getDynamicMod().getxGain() + "," );
	}
	
	public void moveObjects(){
		//Gets the change in milliseconds since the last update
		long delta=System.currentTimeMillis()-lastDrawTime;
		//Updates the holder variable with the current time
		lastDrawTime=System.currentTimeMillis();
		//Sets the size of the target to the current size we want
		//Sets the size of the Cursor to be 20% bigger than the target
		long delta2=System.currentTimeMillis()-lastIterationTime;
		if(delta2>=ITERATIONS_DELAY){
			lastIterationTime=System.currentTimeMillis();
			flag=true;
			return;
		}
		else if(delta2>=ITERATIONS_DELAY/2){
				target.move((int) Math.round(targetPositions[targetPositionIndex]+2*screenDimentions.getWidth()/3), (int) Math.round(screenDimentions.getHeight()/2), screenDimentions.width, screenDimentions.height);
				targetPositionIndex++;
			 }
			 else {
				 target.move((int) Math.round(targetPositions[targetPositionIndex]+screenDimentions.getWidth()/4), (int) Math.round(screenDimentions.getHeight()/2), screenDimentions.width, screenDimentions.height);
				 targetPositionIndex++;
			 }
		
		if(targetPositionIndex>=targetPositions.length){
			targetPositionIndex=0;
		}
		warfighter.yCenterPosition=(int) Math.round(screenDimentions.getHeight()/2);
		//Updates the positions of (moves) all the objects on the screen depending on how much time has passed since the last redraw, and the objects position (if the object is near the side of the screen it bounces off it)
		for(ScreenObject o:allOnScreenObjects){
			//prevents the null pointer exception throw
			if(o!=null && !(o instanceof TargetGroup)){
				o.move(delta, screenDimentions.width, screenDimentions.height);
			}
		}
		if(flag){
			warfighter.xCenterPosition=target.xCenterPosition;
			warfighter.yCenterPosition=target.yCenterPosition;
			flag=false;
		}
	}
	
	public void initObjects(){
		//Initializes Curseor
		warfighter=new CursorLine(screenDimentions.width/8);
		warfighter.setScreenHeight(screenDimentions.height);
		//Allows the Curseor to take in joystick input
		warfighter.setDynamicsModel(new DynamicsModel(stick,XGain,0));

		//Initializes the Target
		Target t1=new Target(200.0,0.018);
		Target t3=new Target(200.0,0.018);
		Target t5=new Target(200.0,0.018);
		Target t2=new Target(20.0,1.0);
		Target t4=new Target(20.0,1.0);
		Target t6=new Target(20.0,1.0);
		double[] radii={200,200,200,200,200,200};
		double[] thetas={-30,-90,-150,-210,-270,-330};
		Target[] scs={t1,t2,t3,t4,t5,t6};
		target=new TargetGroup(targetPositions[0],screenDimentions.height/2,0,0,radii,thetas,scs);

		//		for(int i=0;i<numberOfSceneryObjects;i++){
		//			allOnScreenObjects.add(new ScreenObject());
		//		}
		allOnScreenObjects.add(target);
		allOnScreenObjects.add(warfighter);
	}

	public void calibration(Graphics2D g){
		String message="";
		String message2="";
		if(!isCalibrated){
			//Blanks out the current screen
			g.setColor(Color.WHITE);
			g.fillRect(0, 0, getWidth(), getHeight());

			//Sets the font our text will be displayed at to be 24pt Sans Serif (because I like Sans Serif font)
			g.setFont(new Font(Font.SANS_SERIF, Font.PLAIN, 32));
			//Sets the text color to be black
			g.setColor(Color.black);

			//Checks to ensure controller is connected
			if( !stick.isControllerConnected() )
			{
				//If not, print an error in annoying red
				g.setColor(Color.red);
				message2="No controller found!";
			} else

				// Get current state of joystick! And check, if joystick is disconnected.
				if( !stick.pollController() ) {
					//If not, print an error in annoying red
					g.setColor(Color.red);
					message2="Controller disconnected!";
				}
				else {
					/* Sets the text that will be displayed on screen, in this case a modified 
					 * value of the current position the joystick is in. A value of 50 from either 
					 * the .getXAxisPercentage() or getYAxisPercentage() on the stick indicates 
					 * the stick is in the exact center (not pushed) either way with those axes.
					 * For the calibration procedure and to make things simpler, we subtract 50 before display. 
					 * This makes the numbers the user sees on the screen either positive, negative, or zero.
					 * Zero is what the user should aim for. A positive number means the calibration wheel 
					 * associated with either axes is too far forward, a negative meaning it is too far back.
					 * 
					 */
					message=(stick.getXAxisPercentage()-50)+", "+(stick.getYAxisPercentage()-50);
					message2="Use the wheels by the joystick to make\nthe two numbers at the top zero!";
					if(stick.getXAxisPercentage()==50 && stick.getYAxisPercentage()==50){
						message2="Calibration complete";
						isCalibrated=true;
					}

				}
			
			//Prints messages to the screen in the upper-left
			g.drawString(message,0,g.getFontMetrics().getMaxAscent());
			g.drawString(message2,screenDimentions.width/2-g.getFontMetrics().stringWidth(message2)/2,screenDimentions.height/2-g.getFontMetrics().getMaxAscent());			
		}
	}

	public void update(Graphics g){
		paint(g);
	}

	public void paint(Graphics g){

		//    checks the buffersize with the current panelsize
		//    or initialises the image with the first paint
		if(screenDimentions.width!=getWidth() || screenDimentions.height!=getHeight() || canvas==null || canvasGraphics==null)
			resetBuffer();

		if(canvas!=null){
			Color backgroundColor = Color.white;
			
			//this clears the offscreen image, not the onscreen one
			canvasGraphics.setColor(backgroundColor);
			writeErrorToFile();
			canvasGraphics.fillRect(0,0,screenDimentions.width,screenDimentions.height);

			//calls the paintbuffer method with 
			//the offscreen graphics as a param
			updateFrame(canvasGraphics);

			//we finally paint the offscreen image onto the onscreen image
			g.drawImage(canvas,0,0,this);
		}
	}

	public void drawObjectsOnScreen(Graphics2D g){
		if(!isCalibrated){
			calibration(g);
		}
		else {
			g.setColor(Color.black);
			target.draw(g);
			g.setColor(Color.red);
			warfighter.draw(g);
		}
	}

	public void updateFrame(Graphics2D g) {

		synchronized(lock1){
			drawObjectsOnScreen(g);
		}

	}

	/** 
	 * Reinitialize double buffered graphics when canvas changes size
	 */
	public void resetBuffer(){
		// always keep track of the image size
		screenDimentions=getSize();

		//    clean up the previous image
		if(canvas!=null){
			canvas.flush();
			canvas=null;
		}
		if(canvasGraphics!=null){
			canvasGraphics.dispose();
			canvasGraphics=null;
		}
		System.gc();

		//    create the new image with the size of the panel
		canvas=new BufferedImage(screenDimentions.width,screenDimentions.height,BufferedImage.TYPE_INT_ARGB);
		canvasGraphics=(Graphics2D) canvas.getGraphics();
		
		//Makes movement look smoother 
		canvasGraphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		canvasGraphics.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
		canvasGraphics.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);
		canvasGraphics.setRenderingHint(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_ENABLE);
		canvasGraphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
		canvasGraphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
		canvasGraphics.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
		canvasGraphics.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);
	}

	@Override
	public void run() {

		while(Thread.currentThread()==thread && isRunning){
			try{ Thread.sleep(DELAY_TIME);} catch(InterruptedException e) {}
			if(!isRunning)
				break;
			repaint();
		}
	}

	public static void main(String[] args){

		//Creates the frame we will display everything on and titles it (text at the top) "IMPORTANT RESEARCH PROGRAME"
		//Creates an instance of this class. Basically this line creates a 'canvas' (think painting canvas) that has a 
		//picture of the way everything looks. This picture changes over time; this is the point of a flight simulator. 
		//If it was a still picture it would be boring
		MainExperimentGroupLine m=new MainExperimentGroupLine();
		while(m.isRunning){
			try{Thread.sleep(MainExperimentGroupLine.DELAY_TIME);} catch(InterruptedException e) {}
		}
		System.out.println("Writing complete! Closing...");
		System.exit(0);
	}
	
	public int stringToInt(String str){
		str=str.trim();
		int out=0;
		for(int i=0;i<str.length();i++){
			out+=Math.pow(10,(str.length()-1-i))*((int)str.charAt(i)-48);
		}
		return out;
	}
}
