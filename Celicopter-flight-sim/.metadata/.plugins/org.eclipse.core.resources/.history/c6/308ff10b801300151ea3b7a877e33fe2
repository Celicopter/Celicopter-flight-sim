import java.awt.Graphics;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.ArrayList;

import javax.swing.*;

import joystick.JInputJoystick;


public class MainResearchProgram extends JPanel{
	
	/**Represents the bounds of the window. Expands to occupt two monitors*/
	protected Rectangle virtualBounds;
	/**Represents the target object to track*/
	protected Target sc;
	/**Holds all the things on the screen that the user doesnt have to track. This is the scenery*/
	protected ArrayList<ScreenObject> scenery;
	/**Represents the on-screen object the user controls. The class name Cursor was already taken so for our class we simply misspelled the word*/
	protected Curseor sc1;
	/**Holds the last time the loop was run. Used to calculate the speeds at which everything on-screen moves*/
	protected long lastLoopTime;
	/**True if stick and program are calibrated properly*/
	protected boolean isCalibrated;
	/**All the things you would ever want to know about the state of the control stick*/
	protected JInputJoystick stick;
	
	public MainResearchProgram(){
		super();
		/**This code should work for devices with multiple screens*/
		//Defines a variable to hold the maximum bounds of the screen we will find shortly
		virtualBounds = new Rectangle();
		//Gets an object that encapsulates all periphery devices attached to this computer (screens, printers, etc.)
		GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
		//Unpacks this object and gets a list of all peripheries 
		GraphicsDevice[] gs = ge.getScreenDevices();
		//Iterates through this list, going to each device, getting the list of settings with each device, and parsing the maximum window size from these settings  
		for (int j = 0; j < gs.length; j++) {
			//Gets the list of settings associated with the device the for loop is currently on
			GraphicsConfiguration[] gc =gs[j].getConfigurations();
			//Iterates through the settings to get the bounds
			for (int i=0; i < gc.length; i++) {
				virtualBounds =virtualBounds.union(gc[i].getBounds());
			}
		}
		isCalibrated=false;
	}
	
	public void calibration(Graphics g){
		
	}
	
	public static void main(String[] args){
		//Creates the frame we will display everything on and titles it (text at the top) "IMPORTANT RESEARCH PROGRAME"
		JFrame jiff=new JFrame("IMPORTANT RESEARCH PROGRAME");
		
		//Creates an instance of this class. Basically this line creates a 'canvas' (think painting canvas) that has a 
		//picture of the way everything looks. This picture changes over time; this is the point of a flight simulator. 
		//If it was a still picture it would be boring
		MainResearchProgram m=new MainResearchProgram();
		
		//Sets the bounds of the flight-sim to take up all the screens connected
		jiff.setBounds(m.virtualBounds);
		//Makes the frame double-buffered (animation looks smoother)
		jiff.createBufferStrategy(2);
		//Puts our 'canvas' inside the frame
		jiff.add(m);
		//Allows us to see the frame we just made so we can actually see our flight-sim
		jiff.setVisible(true);
		
		//These couple lines make the program stop when we close the window. This is important for not making the computer excessively slow and preventing memory leaks
		jiff.addWindowListener(new WindowAdapter() {
			@Override
			public void windowClosing(WindowEvent e) {
				System.exit(0);
			}//closes window listener that closes the program when we exit out of the window
		}//closes patch
		);
	}
}
